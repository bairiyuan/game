# 🏃‍♂️ 跑酷游戏源码逐行导读 (CS "学渣"逆袭版)

嘿，同学！既然你是计算机专业的，哪怕之前“没好好学”，基本的 `if/else`、`for` 循环、变量赋值这些肯定还是有印象的吧？这就足够了！

这份文档会带你像**Debug**一样，从第一行代码开始，顺着执行流往下看。遇到 TS/JS/Vue 的特有语法，我会用你熟悉的 C/Java 概念来类比。

我们打开 `Parkour.vue`，开始吧！

---

## 🏗️ 附录：游戏数据的幕后黑手 —— parkour.ts

**（先看这个，这相当于我们的“游戏数据库”和“配置中心”）**

如果说 `Parkour.vue` 是游戏的 **CPU**（负责运算逻辑），那么 `parkour.ts` 就是游戏的 **硬盘/ROM**（存储数据）。

这个文件主要做了三件事，体现了 **MVC 模式** 中的 **Model (数据层)**：

### 1. 资源引入 (Resource Loading)
**(第 1-8 行)**
```typescript
import Cactus from '...' 
// 相当于 C 语言加载纹理资源。
// 这一堆 import 就是在告诉程序：“这些图片都在哪，给我准备好”。
```

### 2. 数据结构定义 (Struct Definitions)
**(第 9-56 行)**
这里定义了游戏里各种对象的“模具”。
*   `interface Obstacle`: 定义了障碍物的结构（坐标 x/y、宽高、类型、图片路径）。
*   `interface ObstacleFragment`: **地图块**。这是跑酷游戏的一个核心设计。
    *   游戏地图不是一张无限长的图，而是由很多小片段（Fragment）拼接起来的。
    *   就像搭积木一样，每一块里有几个仙人掌、几个金币，都定义好了。

### 3. 地图配置库 (Level Configuration)
**(第 58 行 `obstacleMap`)**
这是一个巨大的数组（Array），里面存了几十种预设好的地图片段。
*   比如片段 A：地上有两个坑。
*   比如片段 B：天上有两排金币。
*   **设计模式**：这叫 **Prototype Pattern (原型模式)** 或者 **Object Pool (对象池)** 的变种。我们预先设计好关卡，存在这里。

### 4. 随机生成器 (Procedural Generation)
**(第 1309 行 `getRandomObstacleFragment`)**
这是这个文件唯一对外暴露的“功能函数”。
*   **作用**：当 `Parkour.vue` 喊一声“前面没路了，给我来段新路！”，这个函数就从上面的 `obstacleMap` 数组里**随机**挑一段出来。
*   **核心逻辑**：
    1.  **Deep Copy (深拷贝)**: `JSON.parse(JSON.stringify(...))`。从库里拿出来的只是个模版，我们要复制一份新的出来用，不然改了模版下次就没法用了。
    2.  **坐标变换 (Transform)**: 把新片段的坐标 (x, y) 加上当前的偏移量，拼接到当前地图的最后面。
    3.  **资源绑定**: 给障碍物随机分配具体的图片（比如这次是绿树，下次是红树）。

---

##  第一部分：头文件与依赖引入 (Imports)
**(Parkour.vue 第 12-19 行)**

这部分就像 C 语言的 `#include` 或者 Python 的 `import`。

```typescript
import { nextTick, onBeforeUnmount, onMounted, ref } from 'vue'
// 引入 Vue 框架提供的“系统调用”。
// onMounted: 相当于 "程序启动时" (main函数入口)。
// onBeforeUnmount: 相当于 "程序退出前" (析构函数)，用来清理内存。
// ref: 后面细说，最重要的概念。

import { Background, ... } from './parkour'
// 引入同目录下 parkour.ts 里的类型定义 (相当于引入 .h 头文件)。
```

---

## 📐 第二部分：类型定义 (Type Definitions)
**(Parkour.vue 第 20-40 行)**

这里定义了一些数据结构，类似于 C 的 `typedef` 或 `struct`。

```typescript
type GameStatus = 'beforeStart' | 'start' | 'playing' ...
// 这叫“联合类型”。
// 你可以把它理解成一个 Enum (枚举)。
// GameStatus 这个变量只能存这些字符串中的一个，存别的编译器会报错。

const emit = defineEmits<{ ... }>()
// 这是一个“回调函数注册表”。
// Vue 是组件化编程。这个组件(跑酷游戏)是父亲(主程序)的一个子模块。
// emit('close') 就像是子模块给主程序发一个信号（中断/Event）：
// "嘿，我这边完事了，你可以把我关掉了"。
```

---

## 📦 第三部分：全局变量与状态管理 (State)
**(Parkour.vue 第 41-115 行)**

这里定义了游戏运行时的所有数据。在 Vue 里，我们把变量分为两类：

### 1. 普通变量 (`const`/`let`)
```typescript
const canvasWidth = window.innerWidth
let animationId: number | null = null
```
*   这就是普通的局部/全局变量。
*   **注意**：修改它们，数据变了，但**界面不会变**。适合存那些不需要显示在屏幕上的内部数据（比如定时器 ID）。

### 2. 响应式变量 (`ref`) —— **核心概念**
```typescript
const score = ref(0)
const pet = ref<Pet>({ ... })
```
*   **CS 概念映射**：你可以把 `ref(0)` 想象成一个**智能指针** `SmartPtr<int>`。
*   它包裹了一个值。
*   **访问**：在代码里要用 `.value` (比如 `score.value`)，类似于解引用 `*score`。
*   **作用**：这就是“黑魔法”所在。当你修改 `score.value = 100` 时，Vue 框架会监测到写入操作，然后自动触发“重绘”指令，把界面上显示分数的地方更新一下。

### 3. 关键变量解读
*   `ctx`: 画笔 (Canvas Context)。你所有的 `draw` 操作都要通过它。
*   `obstacles`: 障碍物链表（数组）。里面存着当前屏幕上所有的障碍物对象。
*   `pet`: 主角对象。存着它的坐标 (x, y)、大小、当前动作等。

---

## ⚙️ 第四部分：物理引擎参数
**(Parkour.vue 第 99-128 行)**

这里定义了游戏的“物理法则”。

```typescript
let k = 1          // 难度系数。时间越久，k 越大。
let g = 1300 * k * k // 重力加速度。
let vy = 0         // 垂直速度 (Velocity Y)。
let vx = 300 * k   // 水平速度 (Velocity X)。
```

*   `timeKill` 函数：
    *   这是一个定时器回调。每过 1 秒，它把 `k` 加一点点。
    *   **结果**：游戏越玩越快，重力越来越大（跳起来落地更快）。

---

## 🎬 第五部分：核心逻辑 —— 游戏循环 (Game Loop)
**(Parkour.vue 第 355 行 `gameLoop` 函数)**

这是整个游戏的心脏。在游戏开发中，我们不使用阻塞的 `while(true)`，而是使用“每一帧运行一次”的模式。

```typescript
const gameLoop = async () => {
    // 1. 获取当前时间，计算 Delta Time (dt)
    // 这是一个经典技巧：根据上一帧到现在过了多久 (delta)，来决定物体移动多少距离。
    // 距离 = 速度 * 时间 (s = v * t)
    // 这样无论电脑卡不卡，游戏里的物体运动速度看起来是一样的。
    const time = new Date().getTime()
    const delta = time - lastTimeItemFrame
    const movement = (vx * delta) / 1000 

    // 2. 清空画布 (Clear Buffer)
    // 就像画动画片，每一帧都要先擦干净上一帧。
    c.clearRect(0, 0, canvasWidth, canvasHeight)

    // 3. 遍历并更新障碍物 (Update & Draw Obstacles)
    obstacles.value.forEach(async (obstacle, index) => {
        // 3.1 移动障碍物 (逻辑更新)
        obstacle.offsetX -= movement 

        // 3.2 画出来 (渲染)
        await drawImage(...)

        // 3.3 碰撞检测 (Collision Detection)
        // 这里用的是 AABB 算法（轴对齐包围盒）。
        // 简单说就是判断两个矩形是否有重叠区域。
        // if (矩形A在矩形B里面) -> 撞到了！ -> lives - 1
        if (petBottomY >= obstacleY && ...) { ... }
        
        // 3.4 垃圾回收 (GC)
        // 如果障碍物跑出屏幕左边了 (x < 0)，就把它从数组里删掉 (splice)。
        // 否则数组会无限膨胀，内存溢出。
    })

    // 4. 更新主角位置 (Update Pet)
    // 调用 drawPet 函数，处理跳跃逻辑（后面讲）。
    await drawPet(petVal)

    // 5. 递归调用 (Next Frame)
    // requestAnimationFrame 告诉浏览器：“下一帧渲染之前，请再调我一次 gameLoop”。
    // 这就形成了一个无限循环。
    animationId = requestAnimationFrame(gameLoop)
}
```

---

## 🦘 第六部分：跳跃与物理模拟
**(Parkour.vue 第 250 行 `drawPet` 函数)**

这里处理主角怎么动。主角其实**横坐标不变**，只在**纵坐标 (y)** 上动。

```typescript
// 经典的物理公式：v = v0 + at; s = s0 + vt;

if (jumpStatus === 'up') {
    // 上升阶段
    // vy 原本是负数（向上），加上重力 g（向下），速度慢慢变慢，直到变成0。
    vy += g * (delta / 1000) 
    petVal.y += vy * (delta / 1000)
} 
else if (jumpStatus === 'down') {
    // 下落阶段
    // vy 继续增加（越来越快）。
    vy += g * (delta / 1000)
    petVal.y += vy * (delta / 1000)
    
    // 落地检测
    // 如果 y 坐标超过了地面坐标 (sPetY)，强制修正回地面。
    if (petVal.y >= sPetY) {
        petVal.y = sPetY
        vy = 0 // 速度归零
    }
}
```

**交互响应 (`jumpBySpace` 第 599 行)**:
当你按空格时：
1.  把 `vy` 设置为一个负的大数值 (`svy`)，比如 -700。
2.  状态设为 `up`。
3.  物理引擎在下一帧就会根据这个负速度让主角往上飞。

---

## 🏁 第七部分：生命周期 (Lifecycle)
**(Parkour.vue 第 638 行 `onMounted`)**

这是程序的**入口点**。

```typescript
onMounted(async () => {
    initCanvas() // 1. 初始化画布
    
    // 2. 预加载图片资源 (IO密集型操作，所以用了 await)
    await preheat() 
    
    // 3. 注册事件监听 (Event Listener)
    // 告诉浏览器：有人按键盘时，调用 jumpBySpace 函数。
    window.addEventListener('keydown', jumpBySpace)
    
    // 4. 启动游戏循环
    gameLoop()
})
```

**(Parkour.vue 第 672 行 `onBeforeUnmount`)**

这是程序的**出口/析构**。
*   移除事件监听 (否则会内存泄漏，组件销毁了还在后台监听键盘)。
*   停止定时器 (`clearInterval`)。
*   停止动画循环 (`cancelAnimationFrame`)。

---

## 📝 总结：这代码到底在干嘛？

简单说，这段代码就是写了一个**死循环** (`gameLoop`)，每秒钟跑 60 次。
每次循环里：
1.  **算数**：根据物理公式算出主角和障碍物的新位置。
2.  **判断**：看看有没有撞车，有没有得分。
3.  **画图**：把新位置画到屏幕上。

而你按键盘的操作，只是改变了循环里的几个**参数**（比如垂直速度 `vy`），剩下的工作全交给循环里的物理引擎自动完成。

怎么样，用这个视角看代码，是不是觉得逻辑清晰多了？这其实就是最基础的计算机图形学和仿真逻辑！
